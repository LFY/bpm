;;;node code
(define noise-params (pair 0 0))
;;set-growth/label-noise! won't work as desired until eval uses current-envirnoment instead of loading factor-graph.church each time 
(define (set-growth-noise! new-val) (set-car! noise-params new-val))  
(define (set-label-noise! new-val) (set-cdr! noise-params new-val))
(define growth-noise first)
(define label-noise rest)
(define labels '(a b))

(define root '(a))

;;;assumes all node information comes in a list as item0 e.g. (node '(label distance angle) children) where children is a list of nodes
(define f
  (lazify
   (lambda ()
     (flip))))
     ;p(lazy-pair (flip) '()))))


(define (scheme-format->python-format scheme-sexpr)
  (process-nodes scheme-sexpr))

(define (process-nodes scheme-sexpr)
  (if (null? scheme-sexpr)
      '()
      (append (list 'N (process-data (first scheme-sexpr))) (map process-nodes (rest scheme-sexpr)))))

(define (process-data data-list)
  (let ([label (second data-list)]
        [radius (third data-list)]
        [blobbiness (fourth data-list)]
        [distance-info (fifth data-list)]
        [straightness (sixth data-list)])
    (list 'data (pair 'label label) (pair 'radius radius) (pair 'blobbiness blobbiness) (pair 'Distance distance-info) (pair 'Straightness straightness))))

(define node
  (lazify 
    (lambda (item0 . items)
      (if (null? items) (lazy-pair item0 '())
        (lazy-pair item0 (apply node items))))))

;;returns a list that contains all the color information
(define node->data first)

(define (node->color node)
  (second (node->data node)))
(define (node->children node)
  (rest node))

(define data->color second)
(define data->size third)
(define data->attrs rest)

(define (graph->program graph)
  (if (null? graph)
      '()
      (append (list 'node (list 'quote (first graph)))
              (map graph->program (rest graph)))))

;; computing the score of continuous parameters of tree
;(define (compute-color-score tree tree-with-parameters)
;  (if (null? tree)
;    0
;    (+ (single-color-score (node->color tree) (node->color tree-with-parameters)) 
;       (apply + (map compute-color-score 
;                     (node->children tree) 
;                     (node->children tree-with-parameters))))))
;; subroutine: the score of a single tree color
;; basically uses gauss pdf
;(define (single-color-score x mean+variance)
 ; (log (normal-pdf (first x) (first mean+variance) (second mean+variance))))

;;;temporary

; now my problem is making functions for a bunch of different symbols.
(define A0 node)
(define A1 node)
(define A2 node)
(define A3 node)
(define A4 node)
(define A5 node)
(define A6 node)
(define A7 node)
(define A8 node)
(define A9 node)
(define A10 node)


(define (data . sexpr) 
  (if (null? sexpr) (lazy-pair 'data '())
    (lazy-pair 'data (apply node sexpr))))
;(define data node)
(define radius node)
(define size node)
;(define (color x) x)
;(define (color x) (lazify (node (round (gaussian x 25)))))

; The issue is that depending on the type of x, we would like to put it in another lazy-list (node ...)
; or directly return it, if it's a gaussian (as in gaussian-parameters).

(define (number-node x)
  (if (number? x)
    (node (round x))
    x))

(define (color x)
  (if (number? x)  ;;might not be a number if the program is converted to using replace gaussians (should also do this for size)
      (node (round x)) 
      x))
(define blobbiness node)
(define Distance node)
(define Straightness node)
(define label node)
(define N node)
(define G1 node)
(define G2 node)
(define recursive-draw uniform-draw)

;; HTML stuff

(define left number-node)
(define top number-node)
(define width number-node)
(define height number-node)

; SVG stuff;
(define svg node)
(define group node)
(define rect node)

(define x number-node)
(define y number-node)
